{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "kitap-ligi-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "32de6164-2222-4843-9ed4-6c49c386e299",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        2528,
        3968
      ],
      "webhookId": "81c4ed74-1719-476e-85b0-93915a78a260"
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.body.action }}",
        "rules": {
          "rules": [
            {
              "value2": "fetch_book_by_isbn"
            }
          ]
        },
        "fallbackOutput": 1
      },
      "id": "23e360ec-3171-4238-9371-6e711f74733e",
      "name": "Action Yönlendirici",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        2768,
        3968
      ]
    },
    {
      "parameters": {
        "jsCode": "// AKILLI SORGU OLUŞTURUCU (SQL BUILDER)\n// Sözleşme: { action, resource, data, user_id }\n\nconst incoming = $json.body ?? $json;\nconst action = incoming.action;\nlet resource = incoming.resource || null;\nconst data = incoming.data || {};\nconst userId = incoming.user_id || null;\n\nif (!action) {\n  throw new Error('Eksik action alanı');\n}\n\nif (!resource) {\n  if (action === 'get_groups' || action === 'resolve_code') {\n    resource = 'k_t_groups';\n  } else if (action === 'login' || action === 'register') {\n    resource = 'k_t_users';\n  } else if (action === 'log_read' || action === 'dashboard_stats' || action === 'leaderboard_group' || action === 'authority_stats' || action === 'authority_students') {\n    resource = 'k_t_read_logs';\n  } else if (action === 'add_book_edition' || action === 'get_library_books') {\n    resource = 'k_t_book_editions';\n  } else if (action === 'sync_user_badges') {\n    resource = 'k_t_user_badges';\n  }\n}\n\nconst allowedTables = ['k_t_groups', 'k_t_users', 'k_t_read_logs', 'k_t_badges', 'k_t_books', 'k_t_book_editions', 'k_t_user_badges'];\nif (!resource || !allowedTables.includes(resource)) {\n  throw new Error(`Yetkisiz veya eksik tablo erişimi: ${resource || 'Belirtilmedi'}`);\n}\n\nlet query = '';\nlet params = [];\n\nif (action === 'get_groups') {\n  query = `SELECT id, name FROM k_t_groups WHERE type = $1 AND (parent_id = $2 OR ($2 IS NULL AND parent_id IS NULL)) ORDER BY name ASC`;\n  params = [data.type, data.parent_id || null];\n}\nelse if (action === 'resolve_code') {\n  query = `SELECT c.id as class_id, s.id as school_id, d.id as district_id, ci.id as city_id FROM k_t_groups c JOIN k_t_groups s ON c.parent_id = s.id JOIN k_t_groups d ON s.parent_id = d.id JOIN k_t_groups ci ON d.parent_id = ci.id WHERE c.join_code = $1 LIMIT 1`;\n  params = [data.code ? String(data.code).trim().toUpperCase() : ''];\n}\nelse if (action === 'login') {\n  query = `SELECT id, full_name, email, group_id, LOWER(role) AS role FROM k_t_users WHERE LOWER(email) = LOWER($1) AND password_hash = $2 LIMIT 1`;\n  params = [data.email, String(data.password || '')];\n}\nelse if (action === 'register') {\n  query = `WITH existing_user AS (SELECT id, full_name, email, group_id, LOWER(role) AS role FROM k_t_users WHERE LOWER(email) = LOWER($3) LIMIT 1), inserted_user AS (INSERT INTO k_t_users (group_id, full_name, email, password_hash, role) SELECT $1, $2, $3, $4, $5 WHERE NOT EXISTS (SELECT 1 FROM existing_user) RETURNING id, full_name, email, group_id, LOWER(role) AS role) SELECT id, full_name, email, group_id, role, false AS already_exists FROM inserted_user UNION ALL SELECT id, full_name, email, group_id, role, true AS already_exists FROM existing_user LIMIT 1`;\n  params = [data.group_id || null, data.full_name, data.email, String(data.password || ''), String(data.role || 'student').toLowerCase()];\n}\nelse if (action === 'add_book_edition') {\n  query = `WITH existing_book AS (SELECT id FROM k_t_books WHERE LOWER(title) = LOWER($1) AND LOWER(COALESCE(author, '')) = LOWER(COALESCE($2, '')) LIMIT 1), inserted_book AS (INSERT INTO k_t_books (title, author, category) SELECT $1, $2, $3 WHERE NOT EXISTS (SELECT 1 FROM existing_book) RETURNING id), book_pick AS (SELECT id FROM existing_book UNION ALL SELECT id FROM inserted_book LIMIT 1) INSERT INTO k_t_book_editions (isbn, book_id, page_count, thumbnail_url) VALUES ($4, (SELECT id FROM book_pick), $5, $6) ON CONFLICT (isbn) DO UPDATE SET book_id = EXCLUDED.book_id, page_count = EXCLUDED.page_count, thumbnail_url = EXCLUDED.thumbnail_url RETURNING isbn, book_id, page_count, thumbnail_url`;\n  params = [data.title, data.author || null, data.category || null, data.isbn, Number(data.page_count), data.thumbnail_url || null];\n}\nelse if (action === 'get_library_books') {\n  query = `SELECT e.isbn, b.title, b.author, e.page_count, b.category, e.thumbnail_url FROM k_t_book_editions e JOIN k_t_books b ON e.book_id = b.id ORDER BY e.isbn DESC LIMIT $1 OFFSET $2`;\n  params = [Number(data.limit) || 24, Number(data.offset) || 0];\n}\nelse if (action === 'log_read') {\n  if (!userId) throw new Error('log_read için user_id zorunludur');\n  query = `INSERT INTO k_t_read_logs (user_id, book_isbn, pages_read, read_date, note) VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, book_isbn, pages_read, read_date, note`;\n  params = [userId, data.book_isbn, Number(data.pages_read), data.read_date || null, data.note || null];\n}\nelse if (action === 'dashboard_stats') {\n  if (!userId) throw new Error('dashboard_stats için user_id zorunludur');\n  query = `WITH RECURSIVE base AS (SELECT book_isbn, pages_read, read_date::date AS read_date FROM k_t_read_logs WHERE user_id = $1), dates AS (SELECT DISTINCT read_date FROM base WHERE read_date IS NOT NULL), anchor AS (SELECT CASE WHEN EXISTS (SELECT 1 FROM dates WHERE read_date = CURRENT_DATE) THEN CURRENT_DATE WHEN EXISTS (SELECT 1 FROM dates WHERE read_date = (CURRENT_DATE - INTERVAL '1 day')::date) THEN (CURRENT_DATE - INTERVAL '1 day')::date ELSE NULL END AS start_date), streak(d) AS (SELECT start_date FROM anchor WHERE start_date IS NOT NULL UNION ALL SELECT (streak.d - INTERVAL '1 day')::date FROM streak WHERE EXISTS (SELECT 1 FROM dates WHERE read_date = (streak.d - INTERVAL '1 day')::date)) SELECT COALESCE((SELECT COUNT(DISTINCT book_isbn) FROM base WHERE book_isbn IS NOT NULL), 0) AS read_books_count, COALESCE((SELECT SUM(pages_read) FROM base), 0) AS total_pages, COALESCE((SELECT COUNT(*) FROM streak), 0) AS streak_days`;\n  params = [userId];\n}\nelse if (action === 'leaderboard_group') {\n  if (!data.group_id) throw new Error('leaderboard_group için group_id zorunludur');\n  query = `SELECT u.id AS user_id, u.full_name, COALESCE(SUM(r.pages_read), 0) AS total_pages FROM k_t_users u LEFT JOIN k_t_read_logs r ON r.user_id = u.id WHERE u.group_id = $1 AND LOWER(COALESCE(u.role, 'student')) = 'student' GROUP BY u.id, u.full_name ORDER BY total_pages DESC, u.full_name ASC LIMIT $2`;\n  params = [data.group_id, Number(data.limit) || 50];\n}\nelse if (action === 'authority_stats') {\n  query = `WITH monthly AS (SELECT TO_CHAR(DATE_TRUNC('month', read_date), 'YYYY-MM') AS month, SUM(pages_read)::int AS pages FROM k_t_read_logs WHERE read_date IS NOT NULL GROUP BY 1 ORDER BY 1 DESC LIMIT 6) SELECT COALESCE((SELECT SUM(pages_read) FROM k_t_read_logs), 0) AS total_pages, COALESCE((SELECT COUNT(*) FROM k_t_users WHERE LOWER(COALESCE(role, 'student')) = 'student'), 0) AS total_students, COALESCE((SELECT COUNT(DISTINCT user_id) FROM k_t_read_logs WHERE read_date >= (CURRENT_DATE - INTERVAL '30 day')), 0) AS active_students_30d, COALESCE((SELECT COUNT(DISTINCT book_isbn) FROM k_t_read_logs WHERE book_isbn IS NOT NULL), 0) AS distinct_books_started, COALESCE((SELECT JSON_AGG(ROW_TO_JSON(x)) FROM (SELECT month, pages FROM monthly ORDER BY month) x), '[]'::json) AS monthly`;\n}\nelse if (action === 'authority_students') {\n  query = `SELECT u.id AS user_id, u.full_name, u.email, COALESCE(SUM(r.pages_read), 0) AS total_pages, COUNT(DISTINCT r.book_isbn) FILTER (WHERE r.book_isbn IS NOT NULL) AS books_started FROM k_t_users u LEFT JOIN k_t_read_logs r ON r.user_id = u.id WHERE LOWER(COALESCE(u.role, 'student')) = 'student' GROUP BY u.id, u.full_name, u.email ORDER BY total_pages DESC, u.full_name ASC LIMIT $1`;\n  params = [Number(data.limit) || 200];\n}\nelse if (action === 'sync_user_badges') {\n  if (!userId) throw new Error('sync_user_badges için user_id zorunludur');\n  query = `WITH RECURSIVE base AS (SELECT book_isbn, pages_read, read_date::date AS read_date, note FROM k_t_read_logs WHERE user_id = $1), dates AS (SELECT DISTINCT read_date FROM base WHERE read_date IS NOT NULL), anchor AS (SELECT CASE WHEN EXISTS (SELECT 1 FROM dates WHERE read_date = CURRENT_DATE) THEN CURRENT_DATE WHEN EXISTS (SELECT 1 FROM dates WHERE read_date = (CURRENT_DATE - INTERVAL '1 day')::date) THEN (CURRENT_DATE - INTERVAL '1 day')::date ELSE NULL END AS start_date), streak(d) AS (SELECT start_date FROM anchor WHERE start_date IS NOT NULL UNION ALL SELECT (streak.d - INTERVAL '1 day')::date FROM streak WHERE EXISTS (SELECT 1 FROM dates WHERE read_date = (streak.d - INTERVAL '1 day')::date)), metrics AS (SELECT COALESCE((SELECT SUM(pages_read) FROM base WHERE pages_read > 0), 0) AS total_pages, COALESCE((SELECT COUNT(DISTINCT book_isbn) FROM base WHERE note LIKE '[KT_EVENT]FINISH%'), 0) AS total_books, COALESCE((SELECT COUNT(*) FROM streak), 0) AS read_streak), eligible AS (SELECT b.id AS badge_id FROM k_t_badges b CROSS JOIN metrics m WHERE (b.requirement_type = 'total_pages' AND m.total_pages >= b.requirement_value) OR (b.requirement_type = 'total_books' AND m.total_books >= b.requirement_value) OR (b.requirement_type = 'read_streak' AND m.read_streak >= b.requirement_value)), inserted AS (INSERT INTO k_t_user_badges (user_id, badge_id, earned_at) SELECT $1, e.badge_id, NOW() FROM eligible e LEFT JOIN k_t_user_badges ub ON ub.user_id = $1 AND ub.badge_id = e.badge_id WHERE ub.badge_id IS NULL RETURNING badge_id) SELECT b.id, b.name, b.icon_key, b.requirement_type, b.requirement_value, CASE WHEN i.badge_id IS NOT NULL THEN true ELSE false END AS newly_earned FROM k_t_badges b JOIN k_t_user_badges ub ON ub.badge_id = b.id AND ub.user_id = $1 LEFT JOIN inserted i ON i.badge_id = b.id ORDER BY b.requirement_type ASC, b.requirement_value ASC`;\n  params = [userId];\n}\nelse if (action === 'read') {\n  const fields = Array.isArray(data.fields) && data.fields.length > 0 ? data.fields : ['*'];\n  if (fields[0] !== '*') {\n    const invalidField = fields.find((f) => !/^[a-zA-Z0-9_]+$/.test(f));\n    if (invalidField) throw new Error(`Geçersiz field parametresi: ${invalidField}`);\n  }\n\n  const fieldSql = fields[0] === '*' ? '*' : fields.join(', ');\n  query = `SELECT ${fieldSql} FROM ${resource}`;\n\n  if (data.filters && typeof data.filters === 'object' && Object.keys(data.filters).length > 0) {\n    const conditions = [];\n    for (const [key, value] of Object.entries(data.filters)) {\n      if (!/^[a-zA-Z0-9_]+$/.test(key)) throw new Error(`Geçersiz filter anahtarı: ${key}`);\n      params.push(value);\n      conditions.push(`${key} = $${params.length}`);\n    }\n    query += ` WHERE ${conditions.join(' AND ')}`;\n  }\n\n  if (data.order) {\n    const orderValue = String(data.order).trim();\n    if (!/^[a-zA-Z0-9_,.\\s\"]+$/.test(orderValue)) throw new Error('Geçersiz order parametresi');\n    query += ` ORDER BY ${orderValue}`;\n  }\n\n  if (data.limit !== undefined && data.limit !== null) {\n    const limitValue = Number(data.limit);\n    if (!Number.isInteger(limitValue) || limitValue <= 0) throw new Error('Geçersiz limit parametresi');\n    params.push(limitValue);\n    query += ` LIMIT $${params.length}`;\n  }\n\n  if (data.offset !== undefined && data.offset !== null) {\n    const offsetValue = Number(data.offset);\n    if (!Number.isInteger(offsetValue) || offsetValue < 0) throw new Error('Geçersiz offset parametresi');\n    params.push(offsetValue);\n    query += ` OFFSET $${params.length}`;\n  }\n}\nelse {\n  throw new Error(`Tanımsız action: ${action}`);\n}\n\nreturn { query, params, resource };"
      },
      "id": "2614999f-240d-4e73-81eb-d5b894149336",
      "name": "Smart SQL Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3040,
        4144
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $json.query }}",
        "options": {
          "queryReplacement": "={{ $json.params }}"
        }
      },
      "id": "33a0a39b-6f5b-4534-8966-faf84793a1f8",
      "name": "Universal Executor",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3280,
        4144
      ],
      "credentials": {
        "postgres": {
          "id": "chKvdYJk3OigwSvo",
          "name": "n8n_test"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"status\": \"success\",\n  \"resource\": \"{{ $('Smart SQL Builder').item.json.resource }}\",\n  \"data\": {{ JSON.stringify($input.all().map(item => item.json)) }}\n}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "0a7666a9-8e08-468d-b367-1a4bd29b613d",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        3520,
        4144
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT b.title, b.author, b.category, e.page_count, e.thumbnail_url FROM k_t_book_editions e JOIN k_t_books b ON e.book_id = b.id WHERE e.isbn = $1 LIMIT 1",
        "options": {
          "queryReplacement": "={{ [$json.body.isbn || ($json.body.data ? $json.body.data.isbn : null)] }}"
        }
      },
      "id": "2c638f2f-c851-4f49-a0f1-e93b27395f25",
      "name": "Lokal DB Kontrolü",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3040,
        3792
      ],
      "credentials": {
        "postgres": {
          "id": "chKvdYJk3OigwSvo",
          "name": "n8n_test"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.title }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "a78b5230-10f3-402b-9a87-4da7556f846d",
      "name": "Bizde Var Mı?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        3264,
        3792
      ]
    },
    {
      "parameters": {
        "url": "=https://www.googleapis.com/books/v1/volumes?q=isbn:{{ $('Action Yönlendirici').item.json.body.isbn || ($('Action Yönlendirici').item.json.body.data ? $('Action Yönlendirici').item.json.body.data.isbn : '') }}",
        "options": {}
      },
      "id": "d0a348d7-e601-4108-85b4-614ba2266d69",
      "name": "Google Books API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        3520,
        3888
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.all()[0].json;\nif (!data.items || data.items.length === 0) {\n  return [{ json: { status: 'error', message: 'Kitap bulunamadı' } }];\n}\nconst book = data.items[0].volumeInfo;\nreturn [{\n  json: {\n    status: 'success',\n    source: 'google',\n    data: {\n      title: book.title || '',\n      author: book.authors ? book.authors.join(', ') : '',\n      page_count: book.pageCount || 0,\n      thumbnail_url: book.imageLinks ? (book.imageLinks.thumbnail || book.imageLinks.smallThumbnail || '') : '',\n      category: book.categories ? book.categories[0] : 'Diğer'\n    }\n  }\n}];"
      },
      "id": "16d7c464-fc1d-4f7b-bc1e-6a177d38516c",
      "name": "Format Google Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3728,
        3888
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json && $json.title ? { status: 'success', source: 'local', data: { title: $json.title || '', author: $json.author || '', page_count: Number($json.page_count) || 0, thumbnail_url: $json.thumbnail_url || '', category: $json.category || 'Diğer' } } : $json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "9e48a191-beba-448b-b995-46ced1f22119",
      "name": "Cevap Dön",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        3920,
        3888
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Action Yönlendirici",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Action Yönlendirici": {
      "main": [
        [
          {
            "node": "Lokal DB Kontrolü",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Smart SQL Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart SQL Builder": {
      "main": [
        [
          {
            "node": "Universal Executor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Universal Executor": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lokal DB Kontrolü": {
      "main": [
        [
          {
            "node": "Bizde Var Mı?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bizde Var Mı?": {
      "main": [
        [
          {
            "node": "Cevap Dön",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Google Books API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Books API": {
      "main": [
        [
          {
            "node": "Format Google Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Google Data": {
      "main": [
        [
          {
            "node": "Cevap Dön",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "6f076ed0cacd38fc2ba8ffa68ee2e157985f657f98d37b30667e4135afe7d023"
  }
}